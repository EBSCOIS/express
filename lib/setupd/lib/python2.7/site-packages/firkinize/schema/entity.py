# Copyright (c) 2017 Platform9 systems. All rights reserved

import os
import uuid

class EntityMeta(object):
    def __init__(self, key=None, value=None, parent=None):
        self.key = key
        self.value = value
        self.parent = parent

class Entity(object):
    def __init__(self, value=None, *args, **kwargs):
        super(Entity, self).__init__(*args, **kwargs)
        super(Entity, self).__setattr__('__meta__', EntityMeta(value=value))

    @property
    def path(self):
        """
        Build a key path to this object, walk the ancestor tree upward until we
        find an empty parent.
        """
        if self.parent:
            return os.path.join(self.parent.path, self.key)
        elif self.key:
            return self.key
        else:
            return ''

    @property
    def key(self):
        """
        The key associated with this object in its parent.
        """
        return self.__meta__.key

    @property
    def value(self):
        """
        The value of this node. If it has child nodes, it should be None.
        """
        return self.__meta__.value

    @value.setter
    def value(self, value):
        if isinstance(value, Entity):
            self.__meta__.value = value.value
        else:
            self.__meta__.value = value

    @property
    def parent(self):
        """
        The parent object in the keyspace.
        """
        return self.__meta__.parent

    def __setattr__(self, key, value):
        """
        Override setattr so we can give the new attribute a reference to
        its parent, as well as its key.
        If passed something that is not an Entity, it will wrap the value in
        one.
        """
        if key == '__meta__':
            raise AttributeError('You cannot set __meta__')
        entity = value if isinstance(value, Entity) else Entity(value=value)
        super(Entity, self).__setattr__(key, entity)
        entity.__meta__.key = key
        entity.__meta__.parent = self

    def to_kv(self, recurse=False):
        """
        Generate KV pairs for the object, with complete keypaths. Includes a
        python type name so when we deserialize we can use the same class.
        """
        d = {}
        if self.value != None:
            d[self.path] = self.value
        if recurse:
            children = [v for (k, v) in vars(self).iteritems()
                        if k != '__meta__']
            if children:
                d[os.path.join(self.path, '_type')] = '%s.%s' % \
                    (self.__module__, self.__class__.__name__)
                for entity in children:
                    d.update(entity.to_kv(recurse))

        return d

    def load(self, configstore):
        kvdict = configstore.kv_get_prefix(self.path)
        loaded = load(kvdict)
        root = self
        while root.parent != None:
            root = root.parent
        merge(root, loaded)

    def __eq__(self, other):
        if type(other) is not type(self) or \
           self.value != other.value or \
           len(vars(self)) != len(vars(other)):
            return False
        else:
            for name, val in vars(self).iteritems():
                if name != '__meta__' and val != getattr(other, name):
                    return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return '%s(key = %s, value = %s, attributes = %s)' % \
            (self.__class__.__name__, self.key, self.value, vars(self))

class EntityList(Entity, dict):
    def __init__(self, value=None, *args, **kwargs):
        super(EntityList, self).__init__(*args, **kwargs)

    def append(self, entity):
        """
        Add an object to a 'list'. It's not really a list - we assign each
        object a UUID and add it as an entity. Except for this function,
        which autogenerates a UUID key, this object has dict semantics.
        FIXME - maybe make it look more like a list.
        """
        if not isinstance(entity, Entity):
            raise TypeError('%s must be an Entity' % entity)
        else:
            key = str(uuid.uuid4())
            self[key] = entity
            return key

    def __setitem__(self, key, value):
        """
        Override the dictionary's setitem to add a key and parent reference
        to the object.
        If passed something that is not an Entity, it will wrap the value in
        one.
        """
        entity = value if isinstance(value, Entity) else Entity(value=value)
        super(Entity, self).__setitem__(key, entity)
        entity.__meta__.key = key
        entity.__meta__.parent = self

    def to_kv(self, recurse=False):
        """
        Generate KV pairs for the object, with complete keypaths. Includes a
        python type name so when we deserialize we can use the same class.
        FIXME: This is too close to the implementation in Entity. Factory out
        the part that lists children so we can share this.
        """
        d = {}
        if self.value != None:
            d[self.path] = self.value
        if recurse:
            children = self.values()
            if children:
                d[os.path.join(self.path, '_type')] = '%s.%s' % \
                    (self.__module__, self.__class__.__name__)
                for entity in children:
                    d.update(entity.to_kv(recurse))

        return d

    def __eq__(self, other):
        if type(other) is not type(self) or \
           self.value != other.value or \
           len(self) != len(other):
            return False
        else:
            for name, val in self.iteritems():
                if val != other.get(name, None):
                    return False
        return True

    def __repr__(self):
        return '%s(key = %s, value = %s, dict = %s)' % \
            (self.__class__.__name__, self.key, self.value, self.items())

def nodify(kvdict):
    """
    Take a list of multi-element key and value pairs, and collate the elements so
    we have a tree of dictionaries. For example:
        a/b/c/d = 1
        a/b/c/e = 2
        a/b/c/_type = SomeClass
        a/f/g = 3
        a/f/_type = SomeOtherClass
        a/f/h = 4
    becomes:
        a: {
            b: {
                c: {
                    _type: SomeClass
                    d: 1,
                    e: 2
                }
            },
            f: {
                _type: SomeOtherClass
                g: 3,
                h: 4
            }
        }
    """
    def _add_nodes(root, elems, value):
        if len(elems) == 1:
            oldval = root.get(elems[0], None)
            if oldval and isinstance(oldval, dict):
                sys.stderr.write(
                    'Warning: A non-leaf child of \'%s\' has a scalar value '
                    '\'%s\'. The scalar value will not be included '
                    'in the output.\n' % (root, value))
            else:
                root[elems[0]] = value
        else:
            head = elems[0]
            tail = elems[1:]
            newroot = root.get(head, None)
            if not newroot:
                root[head] = {}
                newroot = root[head]
            elif not isinstance(newroot, dict):
                sys.stderr.write(
                    'Warning: A non-leaf child of \'%s\' has a scalar value '
                    '\'%s\'. The scalar value will not be included '
                    'in the output.\n' % (root, value))
                root[head] = {}
                newroot = root[head]
            _add_nodes(newroot, tail, value)

    retval = {}
    for k, v in kvdict.iteritems():
        if v:
            elems = str(k).split('/')
            _add_nodes(retval, elems, v)
    return retval

def load(kvdict):
    """
    Read a list of key-value pairs into objects. First nodifies (See
    above), then instantiates objects and wires them together in a
    tree. If _type isn't found, we default to Entity, which might
    have unexpected effects if you're looking for the EntityList
    semantics.
    """
    ENTITY_TYPE = '%s.%s' % (Entity.__module__, Entity.__name__)
    def _getclass(typename):
        elems = typename.split('.')
        path = '.'.join(elems[:-1])
        clsname = elems[-1]
        module = __import__(path, globals(), locals(), [clsname], -1)
        return getattr(module, clsname)

    def _add_attributes(parent_entity, nodes):
        for key, value in nodes.iteritems():
            if isinstance(value, dict):
                class_ = _getclass(value.get('_type', ENTITY_TYPE))
                new_entity = class_()
                if isinstance(parent_entity, EntityList):
                    parent_entity[key] = new_entity
                else:
                    setattr(parent_entity, key, new_entity)
                _add_attributes(new_entity, value)
            elif key != '_type':
                setattr(parent_entity, key, Entity(value=value))
    node = nodify(kvdict)
    class_ = _getclass(node.get('_type', ENTITY_TYPE))
    root = class_()
    _add_attributes(root, node)
    return root

def merge(dest, source):
    """
    Merge a source tree of Entities into a dest. Overwrites
    unconditionally.
    """
    if type(source) is not type(dest):
        raise TypeError('Attempt to merge %s into %s' %
                        (type(source), type(dest)))
    if source.value != None:
        dest.value = source.value
    if isinstance(source, EntityList):
        for k, source_v in source.iteritems():
            dest_v = dest.get(k, None)
            if  dest_v is not None:
                merge(dest_v, source_v)
            else:
                dest[k] = source_v
    elif isinstance(source, Entity):
        for attr, source_v in vars(source).iteritems():
            if attr != '__meta__':
                dest_v = getattr(dest, attr, None)
                if dest_v != None:
                    merge(dest_v, source_v)
                else:
                    setattr(dest, attr, source_v)
    else:
        raise TypeError('Merge source must be an entity, not %s' %
                        type(source))
