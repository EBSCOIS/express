# Copyright (c) 2017 Platform9 systems. All rights reserved

# pylint: disable=too-many-arguments,too-few-public-methods,broad-except
# pylint: disable=protected-access

import base64
import copy
import json
import logging
import os
import requests
import yaml

from firkinize.configstore.base import (
        ConfigStore,
        ConfigWatch,
        TransactionRollback
        )

LOG = logging.getLogger(__name__)

class _PrefixWatch(ConfigWatch):
    def __init__(self, consul_node, prefix, callback, run_at_startup):
        """
        Create an object that watches a prefix in consul, and calls
        a callback on changes.
        :param consul_node: object of type Consul (below)
        :param prefix: key prefix to watch for changes
        :param callback: Callback function to receive updates. Updates
            match dictionaries like the http responses described here:
            https://www.consul.io/api/kv.html#read-key
        :param run_at_startup: Run the callback with the output of the
            first request from the config store.
        """
        self._consul = consul_node
        self._callback = callback
        self._prefix = prefix
        self._run_at_startup = run_at_startup

        # make sure the prefix exists:
        self._consul.kv_put(self._prefix, '', overwrite=False)

    def run(self):
        """
        Entrypoint for the watch object. Runs forever.
        """
        url = '%s/v1/kv/%s?recurse' % (self._consul.url, self._prefix)
        resp = self._consul.session.get(url)
        resp.raise_for_status()
        update = resp.json()
        if self._run_at_startup:
            self._callback(update)
        index = resp.headers.get('X-Consul-Index', 0)
        LOG.info('Starting watch, index = %s', index)

        while True:
            try:
                index_url = '%s&wait=5m&index=%s' % (url, index)
                resp = self._consul.session.get(index_url)
                resp.raise_for_status()

                new_index = resp.headers.get('X-Consul-Index', 0)
                if new_index == index:
                    LOG.info('Watch timed out with index = %s, starting new '
                             'read...', index)
                else:
                    LOG.info('Watch changed, index = %s', new_index)
                    self._callback(resp.json())
                    index = new_index
            except Exception as e:
                LOG.exception(e)

class Consul(ConfigStore):
    def __init__(self, url, token=None):
        """
        Create an object to talk to consul.
        :param url: usually http://localhost:8500
        """
        self._url = url
        self._session = requests.Session()
        if token:
            self._session.headers['X-Consul-Token'] = token
        self._prefix = ''

    @property
    def url(self):
        return self._url

    @property
    def session(self):
        return self._session

    @staticmethod
    def _decode_val(b64val):
        if b64val:
            return base64.b64decode(b64val)
        else:
            return None

    def _mkurl(self, key):
        return os.path.join(self._url, 'v1/kv', self._prefix, key)

    def kv_get_prefix(self, prefix):
        """
        Get values for the all the keys with the given prefix. Response is
        returned as a dictionary of key-value pairs.
        """
        url = self._mkurl(prefix) + '?recurse'
        resp = self._session.get(url)
        resp.raise_for_status()
        return {kv['Key']: self._decode_val(kv['Value']) for kv in resp.json()}

    def kv_delete_prefix(self, prefix):
        """
        Recursively delete values for the all the keys with the given prefix.
        """
        url = self._mkurl(prefix) + '?recurse'
        resp = self._session.delete(url)
        resp.raise_for_status()

    def kv_get(self, key):
        """
        Get a single value.
        """
        url = self._mkurl(key)
        resp = self._session.get(url)
        resp.raise_for_status()
        return self._decode_val(resp.json()[0]['Value'])

    def kv_put(self, key, value, overwrite=True):
        """
        Insert/update a single value. Returns True if the value was written.
        """
        url = self._mkurl(key)
        if not overwrite:
            url += '?cas=0'
        resp = self._session.put(url, data=value)
        resp.raise_for_status()
        return resp.text == 'true'

    def kv_put_txn(self, updates, modifyIndex=None):
        """
        Put a set of values in a single atomic update.
        :param updates: A flat dictionary of key-value pairs.
        :param modifyIndex: Fail entire txn if any key's ModifyIndex is larger.
            0 fails all overwrites.
            None overwrites unconditionally
        """
        if modifyIndex == None:
            vals = [{
                'KV': {
                    'Verb': 'set',
                    'Key': k,
                    'Value': base64.b64encode(v)
                }
            } for (k, v) in updates.iteritems()]
        else:
            vals = [{
                'KV': {
                    'Verb': 'cas',
                    'Key': k,
                    'Value': base64.b64encode(v),
                    'Index': modifyIndex
                }
            } for (k, v) in updates.iteritems()]
        self.do_txn(vals)

    def kv_put_dict(self, data):
        """
        Put a set of values as specified in a multi-level dictionary. The
        dictionary is first flattened into a single layer of multe-element
        keys and values, then put (non-transactionally) into the store.
        """
        def _flatten(prefix, tree, result):
            for k,v in tree.iteritems():
                new_prefix = os.path.join(prefix, k)
                if isinstance(v, dict):
                    result = _flatten(new_prefix, v, result)
                elif isinstance(v, list):
                    raise ValueError("Elements must be scalars or dicts")
                else:
                    result[new_prefix] = str(v)
            return result

        flat = _flatten('', data, {})
        for k,v in flat.iteritems():
            self.kv_put(k, v)

    def kv_put_yaml(self, filename):
        """
        Read a yaml file, flatten it, and push to the store. Yaml must be
        dicts only, no lists.
        """
        with open(filename, 'r') as f:
            text = f.read()
            doc = yaml.load(text)
        self.kv_put_dict(doc)

    def do_txn(self, updates):
        """
        Write up to 64 updates as a single atomic update. See
        https://www.consul.io/api/txn.html
        """
        if self._prefix:
            pfx_updates = copy.deepcopy(updates)
            for u in pfx_updates:
                u['KV']['Key'] = os.path.join(self._prefix, u['KV']['Key'])
        else:
            pfx_updates = updates
        if len(pfx_updates) > 64:
            raise ValueError(
                'Cannot update more than 64 keys in a transaction')
        else:
            url = '%s/v1/txn' % self._url
            resp = self._session.put(url, data=json.dumps(pfx_updates))
            try:
                resp.raise_for_status()
            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 409:
                    body = e.response.json()
                    raise TransactionRollback(str(body['Errors']))
                else:
                    raise

    def prefix_watch(self, prefix, callback, run_at_startup=True):
        return _PrefixWatch(self, os.path.join(self._prefix, prefix),
                            callback, run_at_startup)

    class PrefixContext(object):
        def __init__(self, consul, prefix):
            self._consul = consul
            self._prefix = prefix
            self._orig_prefix = None
        def __enter__(self):
            self._orig_prefix = self._consul._prefix
            self._consul._prefix = self._prefix
        def __exit__(self, type_, value, traceback):
            self._consul._prefix = self._orig_prefix

    def prefix(self, prefix):
        return Consul.PrefixContext(self, prefix)
