# Copyright (c) 2018 Platform9 systems. All rights reserved

import os
import logging
import base64
from subprocess import Popen, PIPE
from kubernetes import client, config
from firkinize.aws import get_ecr_login_info
from firkinize.decco.mysql import start_mysql
from firkinize.decco.keystone import init_keystone, start_keystone
from firkinize.decco.apps import (
    get_images_and_apps_from_manifest,
    start_app,
    init_region
)
from kubernetes.client.models.v1_secret import V1Secret
from firkinize.k8s.utils import wait_job_complete, copy_secret
from firkinize.decco.api import DeccoApi
from firkinize.decco.keystone import login
from firkinize.state import (
    sync_to_consul,
    prepare_certs,
    generate_customer_and_region_config_for_testing,
)
from firkinize.misc import (
    get_aws_keys_from_env,
    get_registry_url_from_env,
    retry,
    wait_url_returns_expected_statuses,
)
from firkinize.stunnel import (stunnel,
                               generate_stunnel_config,
                               get_stunnel_path_from_env)
from firkinize.k8s.constants import PREEMPTIBLE_NODE_AFFINITY_PREFERENCE

COMMONSVCS_SPACE_NAME = os.getenv('COMMONSVCS_SPACE_NAME', 'global')
config.load_kube_config()
LOG = logging.getLogger(__name__)
stunnel_path = get_stunnel_path_from_env()


def deploy_initial_decco_environment(
    customer_shortname,
    domain,
    container_images_yaml_file,
    http_key,
    http_cert,
):
    """
    Creates a customer configuration, writes it to Consul, creates a
    corresponding space in decco, and deploys Keystone and MySQL in the space.
    The kubernetes cluster is accessed using KUBECTL_PATH and KUBECONFIG
    env vars. The Consul service is assumed to be running in a space whose name
    is stored in COMMONSVCS_SPACE_NAME env var.
    TODO: allow Consul address and token to be passed arguments
    :param customer_shortname: customer shortname to be used as prefix for fqdn
    :param domain: the domain name for the fqdn
    :param container_images_yaml_file: file specifying image names and tags.
           It must at least contain entries for keystone and mysql.
    :param http_key: private key for the web services certificate in PEM form
    :param http_cert: web services certificate in PEM form
    :return a decco deployment info dictionary containing all generated
            credentials, config information, and images and apps info from
            container_images_yaml_file.
    """
    aws_access_key, aws_secret_key = get_aws_keys_from_env()
    registry_url = get_registry_url_from_env()
    docker_user, docker_token = get_ecr_login_info(aws_access_key,
                                                   aws_secret_key,
                                                   registry_url)
    images, apps = get_images_and_apps_from_manifest(
        container_images_yaml_file,
        registry_url, docker_user, docker_token
    )

    keystone_image = images.get('pf9-keystone')
    if not keystone_image:
        raise RuntimeError('pf9-keystone image missing from manifest')
    keystone_tag = keystone_image['tag']
    keystone_image_uri = '%s/pf9-keystone:%s' % (registry_url, keystone_tag)
    keystone_app = apps.get('keystone')
    if not keystone_app:
        raise RuntimeError('pf9-keystone app missing from manifest')
    keystone_endpoints = keystone_app['endpoints']

    (
        customer_fqdn,
        region_name,
        admin_user,
        admin_password,
        customer_uuid,
        region_uuid,
        keystone_admin_pwd,
        db_user,
        db_password
    ) = generate_customer_and_region_config_for_testing(customer_shortname,
                                                        domain)

    certs = prepare_certs(customer_shortname, customer_fqdn,
                          http_cert, http_key)
    tcp_key = certs['v0']['decco-tcp']['key']
    tcp_cert = certs['v0']['decco-tcp']['cert']
    ca_cert = certs['v0']['ca']['cert']
    tcp_cert_secret_name = 'tcp-cert-%s' % customer_shortname
    create_decco_cert_secret(tcp_cert_secret_name,
                             tcp_key, tcp_cert, ca_cert)

    http_cert_secret_name = 'http-cert-%s' % customer_shortname
    create_decco_cert_secret(http_cert_secret_name, http_key, http_cert)

    dapi = DeccoApi()
    global_space_spec = {
        'domainName': domain,
        'httpCertSecretName': http_cert_secret_name,
        'tcpCertAndCaSecretName': tcp_cert_secret_name,
        'deleteHttpCertSecretAfterCopy': True,
        'deleteTcpCertAndCaSecretAfterCopy': True,
        'encryptHttp': True,
    }
    dapi.create_space(customer_shortname, global_space_spec)
    keystone_to_consul_secret_name = 'keystone-to-consul'
    retried_copy_secret(COMMONSVCS_SPACE_NAME, 'tcp-cert',
                        customer_shortname, keystone_to_consul_secret_name)
    db_host = '127.0.0.1'
    start_mysql(customer_shortname, db_password)
    LOG.info('mysql password: %s', db_password)

    commonsvcs_fqdn = '%s.platform9.horse' % COMMONSVCS_SPACE_NAME
    consul_ca_cert, consul_client_cert, consul_client_key = \
        read_consul_certs(COMMONSVCS_SPACE_NAME)
    tmp_dir, stunnel_conf_path = generate_stunnel_config(
        commonsvcs_fqdn, 'consul', 8500, consul_ca_cert,
        consul_client_cert, consul_client_key)
    LOG.info('stunnel conf path: %s' % stunnel_conf_path)

    with stunnel(stunnel_path, stunnel_conf_path, tmp_dir):
        LOG.info('stunnel started')
        keystone_uri = 'https://%s/keystone' % customer_fqdn
        keystone_admin_uri = 'https://%s/keystone_admin' % customer_fqdn
        svc_names = ['keystone', 'resmgr', 'qbert', 'mysqlfs']
        _, dbserver_id = sync_to_consul(
            'http://localhost:8500',
            customer_uuid,
            customer_shortname,
            region_uuid,
            certs,
            customer_fqdn,
            admin_user,
            admin_password,
            keystone_admin_pwd,
            db_user,
            db_password,
            db_host,
            svc_names,
            keystone_internal_uri=keystone_uri,
            keystone_admin_internal_uri=keystone_admin_uri
        )

    img_pull_secr_name = 'regsecret'
    create_dockercfg_secret(customer_shortname, img_pull_secr_name,
                            registry_url, docker_user, docker_token)

    job_name = init_keystone('pf9-keystone',
                             customer_shortname, keystone_image_uri,
                             customer_uuid, region_uuid,
                             img_pull_secr_name,
                             keystone_to_consul_secret_name,
                             tcp_cert_secret_name,
                             COMMONSVCS_SPACE_NAME)
    LOG.info('waiting for init-region job to complete')
    wait_job_complete(customer_shortname, job_name)
    start_keystone(customer_shortname, keystone_image_uri,
                   customer_uuid, region_uuid, img_pull_secr_name,
                   keystone_to_consul_secret_name, tcp_cert_secret_name,
                   keystone_endpoints, COMMONSVCS_SPACE_NAME)

    LOG.info('waiting for keystone to become open')
    LOG.info('obtaining token')
    token_info = retried_login('https://%s' % customer_fqdn,
                               'whoever@example.com', admin_password,
                               'service')
    token = token_info['access']['token']['id']
    tenant_id = token_info['access']['token']['tenant']['id']
    LOG.info('token: %s', str(token_info))

    decco_deployment_info = {
        'name': customer_shortname,
        'fqdn': customer_fqdn,
        'tenant_id': tenant_id,
        'mysql_root_passwd': db_password,
        'customer_uuid': customer_uuid,
        'region_uuid': region_uuid,
        'dbserver_id': dbserver_id,
        'keystone_admin_user': admin_user,
        'keystone_admin_password': admin_password,
        'keystone_token': token,
        'spec': global_space_spec,
        'image_pull_secret_name': img_pull_secr_name,
        'keystone_to_consul_secret_name': keystone_to_consul_secret_name,
        'tcp_cert_secret_name': tcp_cert_secret_name,
        'commonsvcs_space_name': COMMONSVCS_SPACE_NAME,
        'commonsvcs_fqdn': commonsvcs_fqdn,
        'images': images,
        'apps': apps
    }
    return decco_deployment_info


def create_dockercfg_secret(namespace, secret_name, server, user, password):
    kubectl_path = os.getenv('KUBECTL_PATH')
    if not kubectl_path:
        raise Exception('KUBECTL_PATH not defined')
    checked_local_call([
        kubectl_path,
        'create',
        '--namespace=%s' % namespace,
        'secret',
        'docker-registry',
        secret_name,
        '--docker-email=none',
        '--docker-server=%s' % server,
        '--docker-username=%s' % user,
        '--docker-password=%s' % password
    ])


@retry(max_wait=60)
def retried_copy_secret(src_namespace, src_secret_name,
                        dst_namespace, dst_secret_name):
    return copy_secret(src_namespace, src_secret_name,
                       dst_namespace, dst_secret_name)


def checked_local_call(cmd):
    p = Popen(cmd, stdout=PIPE)
    p.wait()
    if p.returncode != 0:
        raise Exception('command %s returned %d' % (' '.join(cmd), p.returncode))
    return p.stdout.read()


def create_decco_cert_secret(secret_name, keydata, certdata, cadata=None):
    """
    Save a cert and key as a kubernetes secret in the decco namespace. If the
    ca cert is provided, save that too.
    """
    v1 = client.CoreV1Api()
    secret = V1Secret(metadata={'name': secret_name})
    secret.data = {
        'tls.crt': base64.b64encode(certdata),
        'tls.key': base64.b64encode(keydata)
    }
    if cadata:
        secret.data['ca.pem'] = base64.b64encode(cadata)
    v1.create_namespaced_secret('decco', secret)


def read_consul_certs(commonsvcs_space_name):
    """
    Returns the client certificate, private key, and CA required to authenticate
    with a Consul service running in the specified space. Assumes the secret
    containing this information is named 'tcp-cert'
    """
    v1 = client.CoreV1Api()
    s = v1.read_namespaced_secret('tcp-cert', commonsvcs_space_name)
    client_key = base64.b64decode(s.data['tls.key'])
    client_cert = base64.b64decode(s.data['tls.crt'])
    ca_cert = base64.b64decode(s.data['ca.pem'])
    return ca_cert, client_cert, client_key


@retry(log=LOG, max_wait=600, interval=10)
def retried_login(*largs, **kwargs):
    return login(*largs, **kwargs)


def deploy_apps(decco_deployment_info):
    """
    Given the specified decco deployment info dictionary containing the
    keys "name", "images" and "apps", calls init-region on all images,
    and deploys all apps. If the set includes keystone and mysql, they won't
    be re-initialized and re-deployed if they already have been by a prior
    call to deploy_initial_decco_environment().
    The name of the space in which the apps are deployed is assumed to be
    stored in the "name" property.
    """
    ddi = decco_deployment_info
    namespace = ddi['name']
    job_names = []
    images = ddi['images']

    for name, image in images.items():
        LOG.info('initializing %s' % name)
        job_name = init_region(
            namespace,
            name,
            image['uri'],
            ddi['customer_uuid'],
            ddi['region_uuid'],
            ddi['image_pull_secret_name'],
            ddi['keystone_to_consul_secret_name'],
            ddi['tcp_cert_secret_name'],
            ddi['commonsvcs_space_name'],
        )
        if job_name:
            job_names.append(job_name)

    for job_name in job_names:
        LOG.info('waiting for %s to complete' % job_name)
        wait_job_complete(namespace, job_name)

    apps = ddi['apps']
    for name, app in apps.items():
        LOG.info('starting %s' % name)
        start_app(namespace,
                  name,
                  app['image_uri'],
                  ddi['customer_uuid'],
                  ddi['region_uuid'],
                  ddi['image_pull_secret_name'],
                  ddi['keystone_to_consul_secret_name'],
                  ddi['tcp_cert_secret_name'],
                  app['endpoints'],
                  app['egresses'],
                  ddi['commonsvcs_space_name'],
                  command=app.get('command'),
                  volumes=app.get('volumes'),
                  volumeMounts=app.get('volumeMounts'),
                  securityContext=app.get('securityContext'),
                  affinity=PREEMPTIBLE_NODE_AFFINITY_PREFERENCE,
                  )


def wait_installer_files_ready_for_download(fqdn):
    download_url = 'https://%s/clarity/platform9-install-redhat.sh' % fqdn
    wait_url_returns_expected_statuses(download_url, (200,))
    pkg_list_url = 'https://%s/private/nocert-packagelist.rpm' % fqdn
    wait_url_returns_expected_statuses(pkg_list_url, (401,))
