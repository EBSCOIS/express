from setupd.common import get_certificate_types, get_password_types
from setupd.certs import generate_root_ca, generate_certificate
from MySQLdb.cursors import DictCursor
from functools import partial
import logging
import uuid
import string
import random

LOG = logging.getLogger(__name__)

"""
Classes used to express configuration data

A configuration consists of:
  - Customer metadata
  - DU metadata:
    - Desired FQDN
    - Release version
  - service certificates
  - service passwords
"""

class MissingField(Exception):
    pass
class NoSuchEntry(Exception):
    pass
class MultipleEntries(Exception):
    pass


VERSION = 1


class ReallyBasicModel(object):
    fields = []

    def _get_me(self, fname=None):
        if fname not in self.model_data:
            self.model_data[fname] = None
        return self.model_data[fname]

    def _set_me(self, val, fname=None):
        self.model_data[fname] = val
        self.dirty = True

    @classmethod
    def _managed_field(cls, field_name):
        return property(
            partial(cls._get_me, fname=field_name),
            partial(cls._set_me, fname=field_name)
            )
        
    def __new__(cls, *largs, **kwargs):
        cls.model_version = VERSION
        for fname in cls.fields:
            setattr(cls, fname, cls._managed_field(fname))
        return super(ReallyBasicModel, cls).__new__(cls)

    def __init__(self, *largs, **kwargs):
        self.id = None
        self.version = self.model_version
        self.model_data = dict()
        self.dirty = False
        for name in self.fields:
            self.model_data[name] = kwargs.get(name, None)

    def on_loaded(self, db):
        pass

    def load_from_db(self, db, **kwargs):
        c = DictCursor(db)
        clauses = {}
        clause_args = {}
        sql_cmd = r'SELECT * FROM %s' % self.table
        if self.id:
            clauses['id'] = r'id = %%s'
            clause_args['id'] = self.id
        if kwargs:
            search_fields = ['id'] + self.fields
            for field, val in kwargs.items():
                if field not in search_fields:
                    LOG.warn('%s not a field in %s',
                        field, self.table)
                    continue
                clauses[field] = r'%s = %%s' % field
                clause_args[field] = val
            if clauses:
                where_stmt = ' AND '.join(clauses.values())
                sql_cmd += ' WHERE ' + where_stmt
        LOG.debug('executing: %s', sql_cmd)
        num_entries = c.execute(sql_cmd, clause_args.values())
        if num_entries == 0:
            raise NoSuchEntry(self.table)
        if num_entries > 1:
            raise MultipleEntries(self.table)
        model_data = c.fetchone()
        self.id = model_data.pop('id')
        self.version = model_data.pop('version', 1)
        for result_field, result_val in model_data.items():
            if result_field not in self.fields:
                LOG.warn('%s not a known %s field',
                         result_field, self.table)
                continue
            self.model_data[result_field] = result_val
        self.dirty = False
        self.on_loaded(db)

    @classmethod
    def load_all_from_db(cls, db, **kwargs):
        entries = []
        c = DictCursor(db)
        clauses = {}
        clause_args = {}
        sql_cmd = r'SELECT * FROM %s' % cls.table
        if kwargs:
            for field, val in kwargs.items():
                if field not in cls.fields:
                    LOG.warn('%s not a field in %s',
                        field, cls.table)
                    continue
                clauses[field] = r'%s = %%s' % field
                clause_args[field] = val
            if clauses:
                where_stmt = ' AND '.join(clauses.values())
                sql_cmd += ' WHERE ' + where_stmt
        LOG.debug('executing: %s', sql_cmd)
        num_entries = c.execute(sql_cmd, clause_args.values())
        LOG.debug('Found %d entries', num_entries)
        for model_data in c.fetchall():
            entry = cls(**model_data)
            entry.id = model_data.pop('id')
            entry.version = model_data.pop('version')
            for result_field, result_val in model_data.items():
                if result_field not in cls.fields:
                    LOG.warn('%s not a known %s field',
                             result_field, cls.table)
                    continue
                entry.model_data[result_field] = result_val
            entry.dirty = False
            entry.on_loaded(db)
            entries.append(entry)
        return entries
            

    def save(self, db):
        if not self.dirty and self.id is not None:
            LOG.debug('%s (%d): no changes, skipping save', self.table, self.id)
            return

        set_cmds = []
        sql_vals = []

        if self.id is not None:
            sql_cmd = 'UPDATE %s SET ' % self.table
        else:
            sql_cmd = 'INSERT INTO %s (%s) VALUES' % \
                (self.table, ', '.join(self.fields))

        for field in self.fields:
            field_val = self.model_data.get(field, None)
            if field_val is not None:
                if self.id is not None:
                    set_cmds.append('%s=%%s' % field)
                else:
                    set_cmds.append('%s')
                sql_vals.append(field_val)
            else:
                set_cmds.append('NULL')
        if self.id is not None:
            sql_cmd += ', '.join(set_cmds) + ' WHERE id=%s'
            sql_vals.append(self.id)
        else:
            sql_cmd += ' (' + ', '.join(set_cmds) + ')'

        c = DictCursor(db)
        LOG.debug('executing: %s', sql_cmd)
        c.execute(sql_cmd, sql_vals)
        db.commit()
        c.close()
        if not self.id:
            self.id = c.lastrowid
        self.dirty = False


class CertificateData(ReallyBasicModel):
    table = 'certificate_data'
    fields = [
        'du_id', 'set_version', 'name',
        'cert_pem', 'private_key_pem'
        ]

    @classmethod
    def generate_ca(cls, cn, du_id, set_version):
        ca_key, ca_cert = generate_root_ca(cn)
        return cls(
            du_id=du_id,
            name='ca',
            set_version=set_version,
            cert_pem=ca_cert,
            private_key_pem=ca_key
            )

    @classmethod
    def generate_certificate(cls, svc_name, ca_cert,
                             du_id=-1, set_version=-1,
                             cn=None, subj_alt_names=[]):
        if set_version == -1:
            set_version = ca_cert.set_version
        if du_id == -1:
            du_id = ca_cert.du_id
        if set_version < 0:
            raise Exception('%s: invalid set_version: %d' % (svc_name, set_version))
        if svc_name == 'ca':
            raise Exception('"ca" service name conflicts with certificate authority data')
        cn = cn or svc_name
        if set_version > 0:
            cn + '-v%d' % set_version
        svc_key, svc_cert = generate_certificate(cn,
                                ca_cert_pem=ca_cert.cert_pem,
                                ca_key_pem=ca_cert.private_key_pem,
                                subj_alt_names=subj_alt_names)
        return cls(
            du_id=du_id,
            name=svc_name,
            set_version=set_version,
            cert_pem=svc_cert,
            private_key_pem=svc_key)


class PasswordData(ReallyBasicModel):
    table = 'passwords'
    fields = [
        'du_id', 'name', 'value'
        ]
    vocab = string.ascii_letters + string.digits

    @classmethod
    def generate_new_password(cls):
        return ''.join([random.choice(cls.vocab) for _ in range(0,16)])

    @classmethod
    def generate(cls, du_id, name):
        new_password = PasswordData.generate_new_password()
        return cls(
            du_id=du_id,
            name=name,
            value=new_password
            )


class CustomerData(ReallyBasicModel):
    table = 'customer_data'
    fields = [
        'admin_user', 'fullname', 'uuid', 'shortname'
        ]

    def save(self, db):
        if not self.uuid:
            self.uuid = str(uuid.uuid4())
        super(CustomerData, self).save(db)

class FeatureData(ReallyBasicModel):
    table = 'features'
    fields = [
        'du_id', 'feature', 'enabled'
        ]


class Configuration(ReallyBasicModel):
    table = 'du_metadata'
    fields = [
        'fqdn', 'uuid', 'phase',
        'region', 'release_version', 'cert_version',
        'customer_id'
        ]

    def __init__(self, *largs, **kwargs):
        super(Configuration, self).__init__(**kwargs)
        if self.cert_version is None:
            self.cert_version = 0
        self.certificates = {}
        self.passwords = {}
        self.features = {}
        self.customer = CustomerData()

    def save(self, db):
        if not self.uuid:
            self.uuid = str(uuid.uuid4())
        if not self.phase:
            self.phase = 'INSERTED'
        customer_id = self.customer.id
        self.customer.save(db)
        if not customer_id:
            self.customer_id = self.customer.id
        super(Configuration, self).save(db)
        for cert_version, cert_set in self.certificates.items():
            for _, cert_data in cert_set.items():
                cert_data.save(db)
        for _, password_data in self.passwords.items():
            password_data.save(db)
        for _, feature_data in self.features.items():
            feature_data.save(db)

    def load_from_db(self, db, fqdn=None,
                     uuid=None, region=None):
        load_args = {}
        if fqdn:
            load_args['fqdn'] = fqdn
        if uuid:
            load_args['uuid'] = uuid
        if region:
            load_args['region'] = region
        super(Configuration, self).load_from_db(db, **load_args)
        self._load_children(db)

    def on_loaded(self, db):
        self._load_children(db)

    def _load_children(self, db):
        if self.cert_version is None:
            self.cert_version = 0
        # TODO: lazy-load these?
        if self.customer_id:
            self.customer.load_from_db(db, id=self.customer_id)

        for cert_data in CertificateData.load_all_from_db(
                db, du_id=self.id):
            name = cert_data.name
            set_version = cert_data.set_version
            if set_version not in self.certificates:
                self.certificates[set_version] = {}
            self.certificates[set_version][name] = cert_data

        for passwd_data in PasswordData.load_all_from_db(
                db, du_id=self.id):
            name = passwd_data.name
            self.passwords[name] = passwd_data

        for feature_data in FeatureData.load_all_from_db(
                db, du_id=self.id):
            feature_name = feature_data.feature
            self.features[feature_name] = feature_data

    def sync_certificates(self):
        if not self.customer or not self.customer.shortname:
            raise Exception('Cannot synchronize certificate info '
                            'without customer data')
        if self.cert_version not in self.certificates:
            self.certificates[self.cert_version] = {}
        cert_set = self.certificates[self.cert_version]
        if 'ca' not in cert_set:
            cert_set['ca'] = CertificateData.generate_ca(
                cn=self.customer.shortname,
                du_id=self.id,
                set_version=self.cert_version)
        for cert_name, cert_info in get_certificate_types().items():
            if cert_name not in cert_set:
                LOG.info('Generating cert for %s (v%d)', cert_name, self.cert_version)
                cn = cert_info.get('cn', None)
                cert_set[cert_name] = CertificateData.generate_certificate(
                    cert_name, cert_set['ca'],
                    du_id=self.id, set_version=self.cert_version,
                    cn=cn)

    def sync_passwords(self):
        for password_name in get_password_types():
            if password_name not in self.passwords:
                LOG.info('Generating %s password', password_name)
                self.passwords[password_name] = \
                    PasswordData.generate(
                        self.id, password_name)

    def set_feature(self, feature_name, enabled):
        if type(enabled) != bool:
            raise Exception('Feature enablement value must be boolean')
        if feature_name not in self.features:
            self.features[feature_name] = FeatureData(
                du_id=self.id, feature=feature_name
                )
        self.features[feature_name].enabled = enabled

    def has_feature(self, feature_name):
        if feature_name not in self.features:
            return False
        return self.features[feature_name].enabled == True
