#!/opt/pf9/setupd/bin/python2
# Copyright (c) 2014 Platform9 System Inc.

from ConfigParser import ConfigParser
import datetime
from functools import wraps
import iso8601
import json
import logging
from multiprocessing import Pool
import argparse
import os
import pytz
import requests
from subprocess import PIPE, Popen
import sys
import time
import traceback
import warnings
import docker
import re
import yaml
from setupd_samples.utils import command_exec
from setupd_samples.utils.pf9_utils import login, upgrade_cluster

# Ignore insecure SSL warning since we don't verify certs
warnings.filterwarnings("ignore")

logging.basicConfig(level=logging.DEBUG,
                    format=('%(asctime)s %(name)-12s '
                            '%(levelname)-8s %(message)s'),
                    datefmt='%m-%d %H:%M')

for logger in 'requests', 'urllib3', 'iso8601':
    logging.getLogger(logger).setLevel(logging.WARNING)

log = logging.getLogger('upgrade-hostagents')

bbmaster_endpoint = 'http://localhost:8082/v1/hosts'
keystone_endpoint = 'http://localhost:8080/keystone_admin/v2.0'
resmgr_endpoint = 'http://localhost:8083/v1'
sidekick_endpoint = 'http://localhost:3011/v1/hosts'

default_tenant = 'service'


def retry(timeout=10 * 60, interval=20):
    """
    Retry a function until an exception is not thrown.
    Otherwise, throw the exception when the timeout occurs.
    Numbers are in seconds.
    """
    def wrapper(f):
        @wraps(f)
        def wrapped_f(*args, **kwargs):
            wait_time = 0
            while True:
                try:
                    return f(*args, **kwargs)
                except:
                    if wait_time >= timeout:
                        raise
                    time.sleep(interval)
                    wait_time += interval
        return wrapped_f
    return wrapper


def local_query(url, token=None, action='get', body=None):
    headers = {'Content-Type': 'application/json'}
    if token:
        headers['X-Auth-Token'] = token
    resp = requests.request(action,
                            url,
                            verify=False,
                            json=body,
                            headers=headers)
    resp.raise_for_status()
    return resp.json()


def get_resmgr_hosts(token):
    url = '/'.join([resmgr_endpoint, 'hosts'])
    return local_query(url, token)


def get_resmgr_host(token, host):
    url = '/'.join([resmgr_endpoint, 'hosts', host['id']])
    return local_query(url, token)


def upgrade_role(token, host, role):
    url = '/'.join([resmgr_endpoint, 'hosts', host['id'], 'roles', role])
    return local_query(url, token, 'put')


def send_support_command(token, host, command):
    body = {'command': command}
    url = '/'.join([resmgr_endpoint, 'hosts', host['id'],
                    'support', 'command'])
    return local_query(url, token, 'post', body)


def get_app_versions(token, role):
    url = '/'.join([resmgr_endpoint, 'roles', role, 'apps', 'versions'])
    return local_query(url, token)


def get_bbmaster_host(host_id):
    url = '/'.join([bbmaster_endpoint, host_id])
    return local_query(url)


def get_sidekick_host(host_id):
    url = '/'.join([sidekick_endpoint, host_id])
    return local_query(url)


def upgrade_bbmaster_hostagent(host_id, version, debian):
    req_url = '/'.join([bbmaster_endpoint, host_id, 'hostagent'])
    pkgtype = 'deb' if debian else 'rpm'
    hostagent_file = 'pf9-hostagent-{0}.x86_64.{1}'.format(version, pkgtype)
    hostagent_url = 'http://localhost:9080/private/{0}'.format(hostagent_file)
    body = {
        'version': version,
        # TODO why is name needed?
        'name': 'pf9-hostagent',
        'url': hostagent_url
    }
    return local_query(req_url,
                       action='put',
                       body=body)


def restart_sidekick_client(token, host):
    send_support_command(token, host, 'sudo service pf9-sidekick restart')

def sidekick_pre_tasks(token, host, outfile):
    """
    IAAS-6116 / IAAS-6230
    Verify that sidekick is responding and is at the expected version.
    Sidekick may be restarted to ensure the new version is running.
    """
    sk_initially_responding = True
    try:
        wait_sidekick_responding(host)
    except:
        log_to_file('sidekick client not initially responding', outfile)
        sk_initially_responding = False

    if sk_initially_responding:
        # ensure sk client's pid changes
        old_pid = get_sidekick_host(host['id']).get('pid')
        wait_sidekick_restart(token, host, old_pid)
    else:
        # ensure sk client's responds after reboot
        restart_sidekick_client(token, host)
        wait_sidekick_responding(host)
        log_to_file('sidekick client responding after reboot', outfile)


def sidekick_post_tasks(token, host):
    """
    IAAS-6116
    Reboot SK client to ensure it uses latest certs and code version.
    """
    # Need a special restart mechanism for sidekick to deal with hostagent and
    # sidekick moving from service init scripts to systemd
    send_support_command(token, host, '/opt/pf9/comms/service-scripts/sidekick-restarter.sh')
    wait_sidekick_responding(host)


def responding_within_threshold(current_time, timestamp):
    time_delta = current_time - timestamp
    threshold = datetime.timedelta(minutes=3)
    return time_delta <= threshold and -time_delta <= threshold


@retry(timeout=5*60)
def wait_sidekick_responding(host):
    current_time = datetime.datetime.utcnow().replace(tzinfo=pytz.UTC)
    sidekick = get_sidekick_host(host['id'])
    sidekick_timestamp = iso8601.parse_date(sidekick['timestamp'])
    sidekick_timestamp_on_du = iso8601.parse_date(sidekick['timestamp_on_du'])

    responding = responding_within_threshold(current_time, sidekick_timestamp)
    responding_on_du = responding_within_threshold(current_time,
                                                   sidekick_timestamp_on_du)

    if not responding and not responding_on_du:
        msg = ('Failed while waiting for sidekick to respond'
               'for host {0} ({1}).\n'
               'Last timestamp: {2}\n'
               'Last timestamp on du: {3}')
        raise Exception(msg.format(sidekick['hostname'],
                                   sidekick['hostid'],
                                   sidekick['timestamp'],
                                   sidekick['timestamp_on_du']))


@retry(timeout=10*60)
def wait_sidekick_restart(token, host, old_pid):
    sidekick = get_sidekick_host(host['id'])
    if sidekick['pid'] != old_pid:
        return True
    send_support_command(token, host, 'sudo service pf9-sidekick restart')
    msg = ('Failed while waiting for sidekick to restart '
           'for host {0} ({1})\n'
           'PID: {2}')
    raise Exception(msg.format(sidekick['hostname'],
                               sidekick['hostid'],
                               old_pid))


@retry(timeout=30*60)
def wait_hostagent_version(host_id, version):
    agent = get_bbmaster_host(host_id)['host_agent']
    if agent['status'] != 'running' or agent['version'] != version:
        msg = ('Failed while waiting for hostagent to update\n'
               'Status: {0}\n'
               'Version: {1}')
        raise Exception(msg.format(agent['status'], agent['version']))


def upgrade_hostagent(host, version, debian, wait=True):
    upgrade_bbmaster_hostagent(host['id'], version, debian)
    if not wait:
        return

    wait_hostagent_version(host['id'], version)
    # This sleep is the unfortunate side effect of IAAS-8083. The host agent
    # does a self restart after 5 secs of the hostagent update completing.
    # This sleep is to ensure that we don't push roles till that restart has
    # completed and things have stabilized.
    time.sleep(60)


def upgrade_roles(token, host, deployment_type, outfile, wait=True, roles_to_skip=None):
    if not roles_to_skip:
        roles_to_skip = []
    roles_to_upgrade = []
    for role in host['roles']:
        if role in roles_to_skip:
            msg = 'Host {0} ({1}) skipping role {2} upgrade' \
                   .format(host['info']['hostname'], host['id'], role)
            log_to_file(msg, outfile)
        else:
            roles_to_upgrade.append(role)

    for role in roles_to_upgrade:
        upgrade_role(token, host, role)

    if not wait:
        return

    failure_msgs = []
    for role in roles_to_upgrade:
        try:
            wait_for_role(token, host['id'], role)
        except Exception as e:
            failure_msgs.append(e.message)
    if failure_msgs:
        msg = ('Host {0} ({1}) failed while waiting for roles to update'
               .format(host['info']['hostname'], host['id']))
        failure_msgs.insert(0, msg)
        raise Exception('\n'.join(failure_msgs))


def wait_for_role(token, host_id, role):
    app_versions = get_app_versions(token, role)

    @retry(timeout=30*60)
    def wait_for_role_helper(token, host_id, role, app_versions):
        host = get_bbmaster_host(host_id)
        if (host['status'] != 'ok' or
                any(app not in host['apps'] or
                    host['apps'][app]['version'] != app_version
                    for app, app_version in app_versions.iteritems())):

            raise Exception('Failed to update role: {0}'.format(role))

    return wait_for_role_helper(token, host_id, role, app_versions)

def _copy_to_nginx_container(version):
    command_exec.call("docker cp pf9-resmgr:/opt/pf9/www/private/pf9-hostagent-%s.x86_64.rpm /tmp" % version)
    command_exec.call("docker cp /tmp/pf9-hostagent-%s.x86_64.rpm pf9-nginx:/opt/pf9/www/private/pf9-hostagent-%s.x86_64.rpm" % (version, version))
    command_exec.call("docker cp pf9-resmgr:/opt/pf9/www/private/pf9-hostagent-%s.x86_64.deb /tmp" % version)
    command_exec.call("docker cp /tmp/pf9-hostagent-%s.x86_64.deb pf9-nginx:/opt/pf9/www/private/pf9-hostagent-%s.x86_64.deb" % (version, version))


def _get_latest_hostagent():
    client = docker.from_env(version='auto')
    output = client.containers.get("pf9-resmgr").exec_run("ls /opt/pf9/www/private")
    print "Output of exec inside resmgr container = " + output
    match = re.search("pf9-hostagent-(.+?).x86_64.rpm", output)
    return match.group(1)


def info(fqdn, webhook_url, msg):
    send_to_webhook(fqdn, webhook_url, msg)


def serious(fqdn, webhook_url, msg):
    send_to_webhook(fqdn, webhook_url, msg, True)


def send_to_webhook(fqdn, webhook_url, msg, serious=False):
    if not webhook_url:
        return
    try:
        requests.post(webhook_url, {'serious': serious,
                                    'fqdn': fqdn,
                                    'msg': msg})
    except Exception as e:
        log.warn('Failed to post to Slack: {0}'.format(e))


def log_to_file(text, outfile):
    timestamp = datetime.datetime.now(pytz.utc).isoformat()
    with open(outfile, 'a') as f:
        f.write(timestamp + ': ' + str(text) + '\n')

def last_response_time(host):
    if 'last_response_time' in host['info']:
        # last_response_time is null if still connected
        return host['info']['last_response_time'] or 'recently'
    else:
        # host unauthorized or in a weird state
        return 'unknown'

def wait_for_host_responding(token, host, poll_interval):
    @retry(timeout=20 * poll_interval, interval=poll_interval)
    def wait_for_host_responding_helper(token, host):
        get_bbmaster_host(host['id'])
        host = get_resmgr_host(token, host)
        if not host['info']['responding']:
            raise Exception('Timeout waiting for {0} ({1}) to respond'
                            .format(host['info']['hostname'], host['id']))
    return wait_for_host_responding_helper(token, host)


def raise_if_unauthed(host):
    if not host['roles']:
        raise Exception('Host {0} ({1}) unauthorized'
                        .format(host['info']['hostname'], host['id']))


def upgrade_host((username, password, token, fqdn, webhook_url, poll_interval,
                 host, deployment_type, hostagent_version, outdir,
                 roles_to_skip)):
    """
    Due to python issue5228, this function only takes 1 argument
    :param host: the JSON from resmgr describing the host
    """
    hostname = host['info']['hostname']
    # Log to a file to avoid interleaved log messages
    outfile = os.path.join(outdir, 'host-{0}.log'.format(hostname))
    status_output = {'id': host['id'], 'hostname': hostname, 'status': 'NOK'}
    msg = ('Host {0} {1} upgrade starting {2}'
           .format(hostname, host['id'], hostagent_version))
    info(fqdn, webhook_url, msg)

    try:
        raise_if_unauthed(host)
        print "Checked pass: host is authorized"
        # Wait for hosts to reconnect
        wait_for_host_responding(token, host, poll_interval)
        print "Checked pass: host is responding"
        # In case the hostagent does not have a bbslave-q, send a message
        # so it will be declared. See IAAS-3965.
        send_support_command(token, host, 'sudo service pf9-hostagent status')
        print "Sent command to host"

        debian = any(dist in host['info']['os_info'].lower()
                     for dist in ('debian', 'ubuntu'))

        sidekick_pre_tasks(token, host, outfile)
        print "Completed sidekick pre tasks"

        upgrade_hostagent(host, hostagent_version, debian, wait=True)
        print "Completed host agent upgrade"

        upgrade_roles(token, host, deployment_type, outfile, wait=True,
                      roles_to_skip=roles_to_skip)
        print "Completed role update skipped " + str(roles_to_skip)

        sidekick_post_tasks(token, host)
        print "Completed sidekick post tasks"


        status_output['status'] = 'OK'
    except Exception as e:
        msg = hostname + ': ' + str(e) + ' (last response time was {0})'.format(
                                            last_response_time(host))
        status_output['message'] = msg
        serious(fqdn, webhook_url, msg)
        log_to_file(traceback.format_exc(), outfile)
    else:
        msg = 'Host {0} upgrade successful'.format(hostname)
        info(fqdn, webhook_url, msg)

    return status_output


def upgrade_agent(username, password, outdir, fqdn, webhook_url, deployment_type,
              roles_to_skip):
    token = login(fqdn, username, password, 'service')
    print "logged into DU"
    hostagent_version = _get_latest_hostagent()
    print "Got hostagent version " + hostagent_version

    #should ideally not be needed
    _copy_to_nginx_container(hostagent_version)
    hosts = get_resmgr_hosts(token)
    poll_interval = 15
    msg = "Hosts to be upgraded: {0}".format(len(hosts))
    info(fqdn, webhook_url, msg)
    log.info(msg)

    num_workers = min(os.environ.get('HOST_UPGRADE_WORKERS', 15),
                      max(len(hosts), 1))

    pool = Pool(num_workers)
    hosts_status = pool.map(upgrade_host, [(username, password, token,
                                           fqdn, webhook_url, poll_interval,
                                           host, deployment_type,
                                           hostagent_version, outdir,
                                           roles_to_skip)
                                           for host in hosts])
    status = {
        'date': datetime.datetime.utcnow().strftime('%Y-%m-%d-%H:%M:l%S'),
        'hosts': hosts_status
    }

    num_failed_hosts = sum(1 for host in hosts_status
                           if host['status'] != 'OK')
    if num_failed_hosts:
        msg = '{0} hosts failed to upgrade'.format(num_failed_hosts)
    else:
        msg = 'Hosts upgraded successfully'

    info(fqdn, webhook_url, msg)
    log.info(msg)
    status_file = os.path.join(outdir, 'host_status.json')
    with open(status_file, 'w') as f:
        f.write(json.dumps(status, indent=3))


def main():
    current_time = datetime.datetime.utcnow() \
            .replace(tzinfo=pytz.UTC).strftime('%Y-%m-%d_%H-%M-%S')

    with open("/etc/pf9/pf9-config.yaml", 'r') as stream:
        conf = yaml.load(stream)

    output_dir = '/var/log/pf9/upgrade_hosts/{0}'.format(current_time)

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    upgrade_agent(conf['sys_config']['default_user'],
               conf['sys_config']['default_password'],
               output_dir,
               conf['sys_config']['mgmt_fqdn'], None,
               'kvm',
               'pf9-kube')
    auth = login(conf['sys_config']['mgmt_fqdn'], conf['sys_config']['default_user'], conf['sys_config']['default_password'], 'service')
    upgrade_cluster(auth, conf['sys_config']['mgmt_fqdn'] )

if __name__ == "__main__":
    main()
