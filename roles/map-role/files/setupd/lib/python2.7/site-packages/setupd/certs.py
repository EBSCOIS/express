from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.hashes import SHA256
from cryptography.hazmat.primitives import serialization
from cryptography.x509.oid import NameOID, ExtendedKeyUsageOID
from cryptography.x509.general_name import DNSName
from datetime import datetime, timedelta
import uuid

__all__ = ('generate_root_ca', 'generate_certificate')

def generate_root_ca(cn, expire_days=730):
    """     
    Generates an RSA-based root certificate, stores it in secrets,
    and returns the key/cert PEM-encoded contents

    :param str cn CA Common Name
    :param int expire_days number of days before the certificate expires
    :return the PEM-encoded contents of the new key and cert
    :returntype tuple
    """
    return generate_certificate(cn, is_ca=True, key_size=4096)


def generate_certificate(cn, usages=[],
                         extended_usages=[],
                         is_ca=False, expire_days=730, key_size=2048,
                         ca_cert_pem=None, ca_key_pem=None,
                         subj_alt_names=[]):
    """ 
    Generates an RSA-based server certificate.

    :param str cn Common Name
    :param list usages (optional) usage list ['key_encipherment', 'digital_signature', 'crl_sign', etc.]
    :param list extended_usages (optional) extended usage list ['client_auth', 'server_auth', 'code_signing']
    :param is_ca bool (optional) True if the certificate being generated is a Certificate Authority
    :param int expire_days (optional) Days until certificate expiration, default is 2 years
    :param int key_size (optional) RSA key size, default is 4096 bits
    :param str ca_key_pem (optional) the CA privkey in PEM format to sign the certificate
    :param str ca_cert_pem (optional) the CA certificate in PEM format to sign the certificate
    :param str subj_alt_names (optional) a list of subject alternative names to add to certificate
    :return the PEM-encoded contents of the new key and cert
    :returntype tuple
    """

    # Service certificates need these particular extended usages to
    # function
    extended_usages = list(set(extended_usages) | \
            (set([]) if is_ca else set(['server_auth','client_auth'])))

    newkey = rsa.generate_private_key(public_exponent=65537,
                key_size=key_size, backend=default_backend())
    newpub = newkey.public_key()
    cert_name = x509.Name([
                    x509.NameAttribute(NameOID.COMMON_NAME,
                    cn.decode('utf8'))
                    ])
    builder = x509.CertificateBuilder().subject_name(cert_name)
    builder = builder.not_valid_before(datetime.today() - timedelta(1, 0, 0))
    builder = builder.not_valid_after(datetime.today() + timedelta(expire_days, 0, 0))
    builder = builder.serial_number(int(uuid.uuid4()))
    builder = builder.public_key(newpub)
    builder = builder.add_extension(
        x509.BasicConstraints(ca=is_ca, path_length=None), critical=False,
        )
    builder = builder.add_extension(
        x509.SubjectKeyIdentifier.from_public_key(newpub),
        critical=False
        )
    if len(subj_alt_names):
        # the list of subject alt names MUST include the common name
        sans = [DNSName(unicode(cn))]
        for san in subj_alt_names:
            dns_name = DNSName(unicode(san))
            sans.append(dns_name)
        builder = builder.add_extension(x509.SubjectAlternativeName(sans),
                                        critical=False)
    # CA's cannot be used for signing or encryption of data
    # that are not other certificates
    key_usage = {
        'digital_signature': not is_ca,
        'content_commitment': False,
        'key_encipherment': not is_ca,
        'data_encipherment': False,
        'key_agreement': False,
        'key_cert_sign': is_ca,
        'crl_sign': is_ca,
        'encipher_only': False,
        'decipher_only': False
        }
    extended_usage_oids = {
        'client_auth': ExtendedKeyUsageOID.CLIENT_AUTH,
        'server_auth': ExtendedKeyUsageOID.SERVER_AUTH,
        'code_signing': ExtendedKeyUsageOID.CODE_SIGNING,
        'email_protection': ExtendedKeyUsageOID.EMAIL_PROTECTION
        }
    if not is_ca:
        key_usage_extension_list = [
            extended_usage_oids[eu] for eu in extended_usages if eu in extended_usage_oids
            ]
        builder = builder.add_extension(
            x509.ExtendedKeyUsage(key_usage_extension_list),
            critical=False)
        for usage in usages:
            if usage in key_usage:
                key_usage[usage] = True
            else:
                raise Exception('Usage {0} not supported'.format(usage))
    builder = builder.add_extension(x509.KeyUsage(**key_usage), critical=is_ca)
    
    signing_key = None
    if ca_cert_pem and ca_key_pem:
        # issuer-signed
        cakey = serialization.load_pem_private_key(
            bytes(ca_key_pem),
            password=None, backend=default_backend())
        cacert = x509.load_pem_x509_certificate(
            bytes(ca_cert_pem),
            backend=default_backend())
        builder = builder.add_extension(
            x509.AuthorityKeyIdentifier.from_issuer_public_key(
                cacert.public_key()),
            critical=False)
        builder = builder.issuer_name(cacert.issuer)
        signing_key = cakey
    else:
        # self-signed
        if not is_ca:
            raise Exception('Attempt to generate self-signed server certificate: %s' % cn)
        builder = builder.add_extension(x509.AuthorityKeyIdentifier.from_issuer_public_key(newpub), critical=False)
        builder = builder.issuer_name(cert_name)
        signing_key = newkey
        
    new_cert = builder.sign(private_key=signing_key, algorithm=SHA256(), backend=default_backend())
    return (
        newkey.private_bytes(
            serialization.Encoding.PEM,
            serialization.PrivateFormat.TraditionalOpenSSL,
            serialization.NoEncryption()
            ).strip(),
        new_cert.public_bytes(serialization.Encoding.PEM).strip()
        )
