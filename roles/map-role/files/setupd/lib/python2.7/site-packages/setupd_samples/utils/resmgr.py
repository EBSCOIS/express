import requests
import json
import os
import re
import time
from retry import retry

import logging
LOG = logging.getLogger(__name__)

import requests
import json
import os
import re
import time
from retry import retry

import logging
LOG = logging.getLogger(__name__)

def authorize_host(token, du_ip, host_id, role):
    LOG.info("Authorizing host with config")
    url = 'https://%s/resmgr/v1/hosts/%s/roles/%s' % (du_ip, host_id, role)
    body = {}
    resp = requests.put(url, data=json.dumps(body), verify=False, headers={'X-Auth-Token': token,
                                                          'Content-Type': 'json'})
    resp.raise_for_status()
    wait_host_converged(du_ip, token, host_id)
    return


def get_resmgr_hosts(du_ip_or_fqdn, token):
    url = "https://{du_host}/resmgr/v1/hosts".format(du_host=du_ip_or_fqdn)
    LOG.info("Getting resource manager hosts using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': token})
    response.raise_for_status()
    assert 200 == response.status_code
    return response.json()

def get_resmgr_hosts_v2(context):
    url = "https://{du_host}/resmgr/v1/hosts".format(du_host=context.du_ip)
    LOG.info("Getting resource manager hosts using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': context.token})
    response.raise_for_status()
    assert 200 == response.status_code
    return response.json()

def get_resmgr_roles(du_ip_or_fqdn, token):
    url = "https://{du_host}/resmgr/v1/roles".format(du_host=du_ip_or_fqdn)
    LOG.info("Getting resource manager roles using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': token})
    response.raise_for_status()
    assert 200 == response.status_code
    return response.json()

def get_resmgr_roles_v2(context):
    url = "https://{du_host}/resmgr/v1/roles".format(du_host=context.du_ip)
    LOG.info("Getting resource manager roles using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': context.token})
    response.raise_for_status()
    assert 200 == response.status_code
    return response.json()

@retry(max_wait=600, interval=15, log=LOG)
def wait_for_host_in_resmgr(du_fqdn, token, host_id):
    # Needs host_id to be supplied as param, so can be used only
    # with a deauth/auth sequence and not of 1st time auth.
    LOG.info("Waiting for host- {host} to appear in resmgr".format(host=host_id))
    url = "https://{du_host}/resmgr/v1/hosts/{node}".format(du_host=du_fqdn,
                                                            node=host_id)
    response = requests.get(url, verify=False, headers={'X-Auth-Token': token})
    response.raise_for_status()
    return response.json()

@retry(max_wait=600, interval=15, log=LOG)
def wait_for_node_name_in_resmgr(context, node_name):
    url = "https://{du_host}/resmgr/v1/hosts".format(du_host=context.du_fqdn)
    response = requests.get(url, verify=False, headers={'X-Auth-Token': context.token})
    response.raise_for_status()
    for host in response.json():
        if host['info']['hostname'] == node_name.lower():
            return host['id']
    return None

@retry(max_wait=600, interval=15, log=LOG)
def wait_for_role_on_node(context, host_id, role_name):
    url = "https://{du_host}/resmgr/v1/hosts/{host_id}/roles/{role_name}".\
                            format(du_host=context.du_fqdn, host_id=host_id,
                                   role_name=role_name)
    LOG.info("Getting resource manager host role using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': context.token})
    response.raise_for_status()
    return response.json()

@retry(max_wait=300, interval=15, log=LOG)
def get_res_mgr_host_id(du_ip_or_fqdn, du_token, hostname, resmgr_hosts=None):
    if resmgr_hosts:
        # Find host with hostname in given list of resource manager hosts
        LOG.info("Given resource manager hosts to find host id = %s" % resmgr_hosts)
    else:
        resmgr_hosts = get_resmgr_hosts(du_ip_or_fqdn, du_token)
        LOG.info("Got resmgr hosts = %s" % resmgr_hosts)
    LOG.info("Looking for host wth hostname = %s in resource manager hosts - %s" % (hostname, resmgr_hosts))
    found_host = [host for host in resmgr_hosts
                    if host['info']['hostname'] == hostname]
    if found_host:
        return found_host[0]['id']
    else:
        return None

@retry(max_wait=180, interval=15, log=LOG)
def get_res_mgr_host_id_v2(context, hostname, resmgr_hosts=None):
    if resmgr_hosts:
        # Find host with hostname in given list of resource manager hosts
        LOG.debug("Given resource manager hosts to find host id = %s" % resmgr_hosts)
    else:
        resmgr_hosts = get_resmgr_hosts(context.du_ip, context.token)
        LOG.debug("Got resmgr hosts = %s" % resmgr_hosts)
    LOG.debug("Looking for host with hostname = %s in resource manager hosts - %s" % (hostname, resmgr_hosts))
    found_host = [host for host in resmgr_hosts
                    if host['info']['hostname'] == hostname]
    if found_host:
        return found_host[0]['id']
    else:
        return None

@retry(max_wait=180, interval=15, log=LOG)
def get_res_mgr_host_id_from_ip(du_ip_or_fqdn, du_token, host_ip):
    resmgr_hosts = get_resmgr_hosts(du_ip_or_fqdn, du_token)
    LOG.info("Got resmgr hosts = %s" % resmgr_hosts)
    for host in resmgr_hosts:
        if host_ip in \
                host.get('extensions', {}).get('ip_address', {}).get('data', []):
            return host['id']
    return None

@retry(max_wait=600, interval=15, log=LOG)
def wait_for_res_mgr_hosts(du_ip_or_fqdn, du_token, host_names):
    resmgr_hosts = get_resmgr_hosts(du_ip_or_fqdn, du_token)
    LOG.info("Found these resource manager hosts - %s " % resmgr_hosts)
    LOG.info("Expecting these host-names -- %s" % host_names)
    if len(resmgr_hosts) != len(host_names):
        LOG.info("All expected resource manager hosts not found")
        return None
    else:
        retrieved_host_names = [host['info']['hostname'] for host in resmgr_hosts]
        if sorted(retrieved_host_names) == sorted(host_names):
            return resmgr_hosts
        else:
            LOG.info("Expected resource manager hosts found to be different"
                     " from actual resource manager hosts")
            return False

def _deauthorize_host(du_ip_or_fqdn, token, host_id):
    url = "https://{du_host}/resmgr/v1/hosts/{host_id}".format(du_host=du_ip_or_fqdn, host_id=host_id)
    LOG.debug("DEAUTH URL: " + url)
    response = requests.delete(url, verify=False,
                           headers={'X-Auth-Token': token, 'Content-Type': 'json'})
    LOG.info("De-authorizing host %s resulted in %s" % (host_id, response.status_code))
    return response.status_code

def deauthorize_host(du_ip_or_fqdn, token, host_id, retry_on_409=False):
    def _func():
        response_status_code = _deauthorize_host(du_ip_or_fqdn, token, host_id)
        return  response_status_code
    def is_ready(s):
        if 409 == s:
            LOG.info("Retry on 409 set to true, so will retry after an interval")
            return False
        else:
            if 200 == s:
                return True
            else:
                raise RuntimeError("De-authorizing host returned %s" % s)
    if retry_on_409:
        return retry(max_wait=300, interval=10, is_ready=is_ready, log=LOG, tolerate_exceptions=False)(_func)()
    else:
        response_status_code = _func()
        assert 200 == response_status_code

def deauthorize_host_v2(context, host_id, retry_on_409=False):
    def _func():
        response_status_code = _deauthorize_host(context.du_ip, context.token, host_id)
        return  response_status_code
    def is_ready(s):
        if 409 == s:
            LOG.info("Retry on 409 set to true, so will retry after an interval")
            return False
        else:
            if 200 == s:
                return True
            else:
                raise RuntimeError("De-authorizing host returned %s" % s)
    if retry_on_409:
        return retry(max_wait=300, interval=10, is_ready=is_ready, log=LOG, tolerate_exceptions=False)(_func)()
    else:
        response_status_code = _func()
        assert 200 == response_status_code

def deauthorize_all_hosts(du_ip_or_fqdn, token):
    all_hosts = get_resmgr_hosts(du_ip_or_fqdn, token)
    for host in all_hosts:
        deauthorize_host(du_ip_or_fqdn, token, host['id'])

def deauthorize_all_hosts_v2(context):
    all_hosts = get_resmgr_hosts_v2(context)
    for host in all_hosts:
        deauthorize_host_v2(context, host['id'])


def get_resmgr_host_custom_settings(du_ip_or_fqdn, token):
    """
    Return a dictionary of host_ids and custom settings.
    """
    host_custom_settings = {}
    for host in get_resmgr_hosts(du_ip_or_fqdn, token):
        host_custom_settings[host['id']] = {}
        for role in host['roles']:
            url = ("https://{du_host}/resmgr/v1/hosts/{host_id}/roles/{role_name}"
                   .format(du_host=du_ip_or_fqdn, host_id=host['id'], role_name=role))
            response = requests.get(url, verify=False, headers={'X-Auth-Token': token})
            response.raise_for_status()
            assert 200 == response.status_code
            host_custom_settings[host['id']][role] = response.json()
    return host_custom_settings


def ensure_hostagents_responding_state(fqdn, token, host_ip, state,
                                       wait_to_converge=False):
    """
    :param wait_to_converge: if true, set the interval to
    the hostagent responsive threshold. This is used to
    ensure the hostagent doesn't change responding state.
    """

    timeout = 210
    if wait_to_converge:
        interval = timeout
    else:
        interval = 30
    while timeout > 0:
        time.sleep(interval)
        timeout -= interval
        hosts = get_resmgr_hosts(fqdn, token)
        for host in hosts:
            ip_addresses = host['extensions']['ip_address']['data']
            for ip in ip_addresses:
                if host_ip == ip:
                    return state == host['info']['responding']

@retry(max_wait=600, interval=5, log=LOG)
def wait_host_roles_not_reported(du_fqdn, token, host_id, roles,
                                 wait_host_unauthorized=True):
    hosts = get_resmgr_hosts(du_fqdn, token)
    LOG.info('Waiting for host %s to be deauthorized, current host list: '
             '%s', host_id, hosts)
    for host in hosts:
        if host['id'] == host_id:
            return not (set(host['roles']) & set(roles))

    if wait_host_unauthorized:
        # host isn't there, it was removed when the last role went away.
        # Host should re-appear after the next host-agent ping.
        # return False and retry.
        return False
    else:
        # Host is not listed and was removed when the last role went away. But
        # in this condition, we don't need to wait for the host to get relisted
        # in resmgr. Example: host is offline/dead. Just return success in such
        # a case.
        return True

@retry(max_wait=600, interval=5, log=LOG)
def wait_host_converged(du_fqdn, token, host_id):
    hosts = get_resmgr_hosts(du_fqdn, token)
    LOG.info('Waiting for host %s to converge, current host list: '
             '%s', host_id, hosts)
    for host in hosts:
        if host['id'] == host_id:
            # if the key's not there, it's 'ok'
            return host.get('role_status', 'ok') == 'ok'
    # host isn't there, it was removed when the last role went away.
    # Host should re-appear after the next host-agent ping.
    # return False and retry.
    return False


def get_resmgr_hosts(du_ip_or_fqdn, token):
    url = "https://{du_host}/resmgr/v1/hosts".format(du_host=du_ip_or_fqdn)
    LOG.info("Getting resource manager hosts using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': token})
    response.raise_for_status()
    assert 200 == response.status_code
    return response.json()

def get_resmgr_hosts_v2(context):
    url = "https://{du_host}/resmgr/v1/hosts".format(du_host=context.du_ip)
    LOG.info("Getting resource manager hosts using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': context.token})
    response.raise_for_status()
    assert 200 == response.status_code
    return response.json()

def get_resmgr_roles(du_ip_or_fqdn, token):
    url = "https://{du_host}/resmgr/v1/roles".format(du_host=du_ip_or_fqdn)
    LOG.info("Getting resource manager roles using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': token})
    response.raise_for_status()
    assert 200 == response.status_code
    return response.json()

def get_resmgr_roles_v2(context):
    url = "https://{du_host}/resmgr/v1/roles".format(du_host=context.du_ip)
    LOG.info("Getting resource manager roles using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': context.token})
    response.raise_for_status()
    assert 200 == response.status_code
    return response.json()

@retry(max_wait=600, interval=15, log=LOG)
def wait_for_host_in_resmgr(du_fqdn, token, host_id):
    # Needs host_id to be supplied as param, so can be used only
    # with a deauth/auth sequence and not of 1st time auth.
    LOG.info("Waiting for host- {host} to appear in resmgr".format(host=host_id))
    url = "https://{du_host}/resmgr/v1/hosts/{node}".format(du_host=du_fqdn,
                                                            node=host_id)
    response = requests.get(url, verify=False, headers={'X-Auth-Token': token})
    response.raise_for_status()
    return response.json()

@retry(max_wait=600, interval=15, log=LOG)
def wait_for_node_name_in_resmgr(context, node_name):
    url = "https://{du_host}/resmgr/v1/hosts".format(du_host=context.du_fqdn)
    response = requests.get(url, verify=False, headers={'X-Auth-Token': context.token})
    response.raise_for_status()
    for host in response.json():
        if host['info']['hostname'] == node_name.lower():
            return host['id']
    return None

@retry(max_wait=600, interval=15, log=LOG)
def wait_for_role_on_node(context, host_id, role_name):
    url = "https://{du_host}/resmgr/v1/hosts/{host_id}/roles/{role_name}".\
                            format(du_host=context.du_fqdn, host_id=host_id,
                                   role_name=role_name)
    LOG.info("Getting resource manager host role using the url - {url}".format(url=url))
    response = requests.get(url, verify=False, headers={'X-Auth-Token': context.token})
    response.raise_for_status()
    return response.json()

@retry(max_wait=300, interval=15, log=LOG)
def get_res_mgr_host_id(du_ip_or_fqdn, du_token, hostname, resmgr_hosts=None):
    if resmgr_hosts:
        # Find host with hostname in given list of resource manager hosts
        LOG.info("Given resource manager hosts to find host id = %s" % resmgr_hosts)
    else:
        resmgr_hosts = get_resmgr_hosts(du_ip_or_fqdn, du_token)
        LOG.info("Got resmgr hosts = %s" % resmgr_hosts)
    LOG.info("Looking for host wth hostname = %s in resource manager hosts - %s" % (hostname, resmgr_hosts))
    found_host = [host for host in resmgr_hosts
                    if host['info']['hostname'] == hostname]
    if found_host:
        return found_host[0]['id']
    else:
        return None

@retry(max_wait=180, interval=15, log=LOG)
def get_res_mgr_host_id_v2(context, hostname, resmgr_hosts=None):
    if resmgr_hosts:
        # Find host with hostname in given list of resource manager hosts
        LOG.debug("Given resource manager hosts to find host id = %s" % resmgr_hosts)
    else:
        resmgr_hosts = get_resmgr_hosts(context.du_ip, context.token)
        LOG.debug("Got resmgr hosts = %s" % resmgr_hosts)
    LOG.debug("Looking for host with hostname = %s in resource manager hosts - %s" % (hostname, resmgr_hosts))
    found_host = [host for host in resmgr_hosts
                    if host['info']['hostname'] == hostname]
    if found_host:
        return found_host[0]['id']
    else:
        return None

@retry(max_wait=180, interval=15, log=LOG)
def get_res_mgr_host_id_from_ip(du_ip_or_fqdn, du_token, host_ip):
    resmgr_hosts = get_resmgr_hosts(du_ip_or_fqdn, du_token)
    LOG.info("Got resmgr hosts = %s" % resmgr_hosts)
    for host in resmgr_hosts:
        if host_ip in \
                host.get('extensions', {}).get('ip_address', {}).get('data', []):
            return host['id']
    return None

@retry(max_wait=600, interval=15, log=LOG)
def wait_for_res_mgr_hosts(du_ip_or_fqdn, du_token, host_names):
    resmgr_hosts = get_resmgr_hosts(du_ip_or_fqdn, du_token)
    LOG.info("Found these resource manager hosts - %s " % resmgr_hosts)
    LOG.info("Expecting these host-names -- %s" % host_names)
    if len(resmgr_hosts) != len(host_names):
        LOG.info("All expected resource manager hosts not found")
        return None
    else:
        retrieved_host_names = [host['info']['hostname'] for host in resmgr_hosts]
        if sorted(retrieved_host_names) == sorted(host_names):
            return resmgr_hosts
        else:
            LOG.info("Expected resource manager hosts found to be different"
                     " from actual resource manager hosts")
            return False

def _deauthorize_host(du_ip_or_fqdn, token, host_id):
    url = "https://{du_host}/resmgr/v1/hosts/{host_id}".format(du_host=du_ip_or_fqdn, host_id=host_id)
    LOG.debug("DEAUTH URL: " + url)
    response = requests.delete(url, verify=False,
                           headers={'X-Auth-Token': token, 'Content-Type': 'json'})
    LOG.info("De-authorizing host %s resulted in %s" % (host_id, response.status_code))
    return response.status_code

def deauthorize_host(du_ip_or_fqdn, token, host_id, retry_on_409=False):
    def _func():
        response_status_code = _deauthorize_host(du_ip_or_fqdn, token, host_id)
        return  response_status_code
    def is_ready(s):
        if 409 == s:
            LOG.info("Retry on 409 set to true, so will retry after an interval")
            return False
        else:
            if 200 == s:
                return True
            else:
                raise RuntimeError("De-authorizing host returned %s" % s)
    if retry_on_409:
        return retry(max_wait=300, interval=10, is_ready=is_ready, log=LOG, tolerate_exceptions=False)(_func)()
    else:
        response_status_code = _func()
        assert 200 == response_status_code

def deauthorize_host_v2(context, host_id, retry_on_409=False):
    def _func():
        response_status_code = _deauthorize_host(context.du_ip, context.token, host_id)
        return  response_status_code
    def is_ready(s):
        if 409 == s:
            LOG.info("Retry on 409 set to true, so will retry after an interval")
            return False
        else:
            if 200 == s:
                return True
            else:
                raise RuntimeError("De-authorizing host returned %s" % s)
    if retry_on_409:
        return retry(max_wait=300, interval=10, is_ready=is_ready, log=LOG, tolerate_exceptions=False)(_func)()
    else:
        response_status_code = _func()
        assert 200 == response_status_code

def deauthorize_all_hosts(du_ip_or_fqdn, token):
    all_hosts = get_resmgr_hosts(du_ip_or_fqdn, token)
    for host in all_hosts:
        deauthorize_host(du_ip_or_fqdn, token, host['id'])

def deauthorize_all_hosts_v2(context):
    all_hosts = get_resmgr_hosts_v2(context)
    for host in all_hosts:
        deauthorize_host_v2(context, host['id'])


def get_resmgr_host_custom_settings(du_ip_or_fqdn, token):
    """
    Return a dictionary of host_ids and custom settings.
    """
    host_custom_settings = {}
    for host in get_resmgr_hosts(du_ip_or_fqdn, token):
        host_custom_settings[host['id']] = {}
        for role in host['roles']:
            url = ("https://{du_host}/resmgr/v1/hosts/{host_id}/roles/{role_name}"
                   .format(du_host=du_ip_or_fqdn, host_id=host['id'], role_name=role))
            response = requests.get(url, verify=False, headers={'X-Auth-Token': token})
            response.raise_for_status()
            assert 200 == response.status_code
            host_custom_settings[host['id']][role] = response.json()
    return host_custom_settings


def ensure_hostagents_responding_state(fqdn, token, host_ip, state,
                                       wait_to_converge=False):
    """
    :param wait_to_converge: if true, set the interval to
    the hostagent responsive threshold. This is used to
    ensure the hostagent doesn't change responding state.
    """

    timeout = 210
    if wait_to_converge:
        interval = timeout
    else:
        interval = 30
    while timeout > 0:
        time.sleep(interval)
        timeout -= interval
        hosts = get_resmgr_hosts(fqdn, token)
        for host in hosts:
            ip_addresses = host['extensions']['ip_address']['data']
            for ip in ip_addresses:
                if host_ip == ip:
                    return state == host['info']['responding']

@retry(max_wait=600, interval=5, log=LOG)
def wait_host_roles_not_reported(du_fqdn, token, host_id, roles,
                                 wait_host_unauthorized=True):
    hosts = get_resmgr_hosts(du_fqdn, token)
    LOG.info('Waiting for host %s to be deauthorized, current host list: '
             '%s', host_id, hosts)
    for host in hosts:
        if host['id'] == host_id:
            return not (set(host['roles']) & set(roles))

    if wait_host_unauthorized:
        # host isn't there, it was removed when the last role went away.
        # Host should re-appear after the next host-agent ping.
        # return False and retry.
        return False
    else:
        # Host is not listed and was removed when the last role went away. But
        # in this condition, we don't need to wait for the host to get relisted
        # in resmgr. Example: host is offline/dead. Just return success in such
        # a case.
        return True

@retry(max_wait=600, interval=5, log=LOG)
def wait_host_converged(du_fqdn, token, host_id):
    hosts = get_resmgr_hosts(du_fqdn, token)
    LOG.info('Waiting for host %s to converge, current host list: '
             '%s', host_id, hosts)
    for host in hosts:
        if host['id'] == host_id:
            # if the key's not there, it's 'ok'
            return host.get('role_status', 'ok') == 'ok'
    # host isn't there, it was removed when the last role went away.
    # Host should re-appear after the next host-agent ping.
    # return False and retry.
    return False
