
import base64
import json
import logging
import mock
import requests

from firkinize.configstore.base import TransactionRollback
from firkinize.configstore.consul import Consul
from firkinize.tests import BaseTestCase
from StringIO import StringIO

LOG = logging.getLogger(__name__)

class TestConsul(BaseTestCase):
    def setUp(self):
        super(TestConsul, self).setUp()
        self._get = self._patchobj(requests.Session, 'get')
        self._put = self._patchobj(requests.Session, 'put')
        self._url = 'http://fake:8500'
        self._consul = Consul(self._url)

    def test_kv_get(self):
        body = [{
            'Key': 'key',
            'Value': base64.b64encode('value')
        }]
        self._get.return_value = self.http_response(200, {}, body)
        self.assertEquals('value', self._consul.kv_get('key'))
        self._get.called_once_with(self._url + '/v1/kv/key')

        # check with prefix context
        self._get.reset_mock()
        with self._consul.prefix('my/prefix'):
            self.assertEquals('value', self._consul.kv_get('key'))
            self._get.called_once_with(self._url + '/v1/kv/my/prefix/key')

    def test_kv_get_prefix(self):
        body = [{
            'Key': 'key-%d' % n,
            'Value': base64.b64encode('value-%d' % n)
        } for n in range(10)]
        self._get.return_value = self.http_response(200, {}, body)

        expected = {'key-%d' % n: 'value-%d' % n for n in range(10)}
        self.assertDictEqual(expected, self._consul.kv_get_prefix('key'))
        self._get.called_once_with(self._url + '/v1/kv/key?recurse')

        # check with prefix context
        self._get.reset_mock()
        with self._consul.prefix('my/prefix'):
            self.assertDictEqual(expected, self._consul.kv_get_prefix('key'))
            self._get.called_once_with(self._url +
                                       '/v1/kv/my/prefix/key?recurse')

    def test_kv_put(self):
        self._consul.kv_put('key', 'value')
        self._put.assert_called_once_with(self._url + '/v1/kv/key',
                                          data='value')

    def test_kv_put_with_prefix(self):
        with self._consul.prefix('my/prefix'):
            self._consul.kv_put('key', 'value')
            self._put.assert_called_once_with(self._url + '/v1/kv/my/prefix/key',
                                              data='value')

    def test_kv_put_txn(self):
        self._consul.kv_put_txn(
            {'key-%d' % n: 'value-%d' % n for n in range(10)})
        expected = [{'KV': {
            'Verb': 'set',
            'Key': 'key-%d' % n,
            'Value': base64.b64encode('value-%d' % n)
        }} for n in range(10)]
        call_url = self._put.call_args[0][0]
        call_data = json.loads(self._put.call_args[1]['data'])
        self.assertEqual(call_url, self._url + '/v1/txn')
        self.assertEqual(len(expected), len(call_data))
        for item in expected:
            self.assertTrue(item in call_data)

    def test_kv_put_txn_with_prefix(self):
        with self._consul.prefix('my/prefix'):
            self._consul.kv_put_txn(
                {'key-%d' % n: 'value-%d' % n for n in range(10)})
        expected = [{'KV': {
            'Verb': 'set',
            'Key': 'my/prefix/key-%d' % n,
            'Value': base64.b64encode('value-%d' % n)
        }} for n in range(10)]
        call_url = self._put.call_args[0][0]
        call_data = json.loads(self._put.call_args[1]['data'])
        self.assertEqual(call_url, self._url + '/v1/txn')
        self.assertEqual(len(expected), len(call_data))
        for item in expected:
            self.assertTrue(item in call_data)

    def test_kv_put_txn_conflict(self):
        # see https://www.consul.io/api/txn.html#sample-response
        self._put.return_value = self.http_response(409, {}, {
            'Errors':[{
                'OpIndex': 0,
                'What': 'The first op failed'
            }]})
        with self.assertRaises(TransactionRollback):
            self._consul.kv_put_txn({'key': 'value'}, modifyIndex=0)
        expected = [{'KV': {
            'Verb': 'cas',
            'Key': 'key',
            'Value': base64.b64encode('value'),
            'Index': 0
        }}]
        call_url = self._put.call_args[0][0]
        call_data = json.loads(self._put.call_args[1]['data'])
        self.assertEqual(call_url, self._url + '/v1/txn')
        self.assertEqual(len(expected), len(call_data))
        for item in expected:
            self.assertTrue(item in call_data)

    def test_kv_put_dict(self):
        data = {
            'k0': 'v0',
            'k1': {
                'k10': 'v10',
                'k11': {
                    'k110': 'v110',
                    'k111': {
                        'k1110': 'v1110'
                    }
                }
            }
        }
        self._consul.kv_put_dict(data)
        expected = {
            'k0': 'v0',
            'k1/k10': 'v10',
            'k1/k11/k110': 'v110',
            'k1/k11/k111/k1110': 'v1110'
        }
        self.assertEqual(len(expected), self._put.call_count)
        for k, v in expected.iteritems():
            self._put.assert_any_call('%s/v1/kv/%s' % (self._url, k), data=v)

        # check with prefix context
        self._put.reset_mock()
        with self._consul.prefix('my/prefix'):
            self._consul.kv_put_dict(data)
        expected_with_prefix = {'my/prefix/' + k: v
                                for (k, v) in expected.iteritems()}
        self.assertEqual(len(expected_with_prefix), self._put.call_count)
        for k, v in expected_with_prefix.iteritems():
            self._put.assert_any_call('%s/v1/kv/%s' % (self._url, k),
                                      data=v)

    def test_watch(self):
        callback = mock.Mock()
        watch = self._consul.prefix_watch('a/b/c', callback,
                                          run_at_startup=False)
        update1 = [{
            'Key': 'a/b/c',
            'Value': base64.b64encode('1')
        }]
        update2 = [{
            'Key': 'a/b/c',
            'Value': base64.b64encode('2')
        }]
        self._get.side_effect = [
            # baseline call:
            self.http_response(200, {'X-Consul-Index': 0}, update1),
            # update 1
            self.http_response(200, {'X-Consul-Index': 1}, update1),
            # redundant call simulating timeout:
            self.http_response(200, {'X-Consul-Index': 1}, update1),
            # update 2
            self.http_response(200, {'X-Consul-Index': 2}, update2),
            # KeyboardInterrupt is not an Exception, so watch exits.
            KeyboardInterrupt()
        ]
        with self.assertRaises(KeyboardInterrupt):
            watch.run()

        # redundant 2nd update1 should be ignored
        callback.assert_has_calls([mock.call(update1), mock.call(update2)])

    def test_watch_with_prefix(self):
        callback = mock.Mock()
        with self._consul.prefix('my/prefix'):
            watch = self._consul.prefix_watch('a/b/c', callback,
                                              run_at_startup=False)
        update = [{
            'Key': 'my/prefix/a/b/c',
            'Value': base64.b64encode('1')
        }]
        self._get.side_effect = [
            # baseline call:
            self.http_response(200, {'X-Consul-Index': 0}, update),
            # update 1
            self.http_response(200, {'X-Consul-Index': 1}, update),
            # KeyboardInterrupt is not an Exception, so watch exits.
            KeyboardInterrupt()
        ]
        with self.assertRaises(KeyboardInterrupt):
            watch.run()

        expected_calls = [
            mock.call(self._url + '/v1/kv/my/prefix/a/b/c?recurse'),
            mock.call(self._url + '/v1/kv/my/prefix/a/b/c?recurse&wait=5m&index=0'),
            mock.call(self._url + '/v1/kv/my/prefix/a/b/c?recurse&wait=5m&index=1')
        ]
        self._get.assert_has_calls(expected_calls)

