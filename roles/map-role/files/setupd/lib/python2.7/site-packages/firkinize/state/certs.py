# Copyright (c) 2018 Platform9 systems. All rights reserved

import os
import logging
from firkinize.vault.ca import VaultCA
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives.serialization import (Encoding,
                                                          PrivateFormat,
                                                          NoEncryption)
LOG = logging.getLogger(__name__)


def prepare_certs(customer_shortname,
                  customer_fqdn,
                  http_cert,
                  http_key,
                  vault=None):
    """
    Prepares a dictionary of certificate data ready for pushing to consul
    in a decco environment. Generates a CA, a hostagent cert, and a TCP services
    cert. The http wildcard cert needs to be passed in as an argument.
    Returns a dictionary that is ready to be written to consul.

    :param customer_shortname: customer short name
    :param customer_fqdn: domain name for all of customer's services
    :param http_cert: the cert for web services in PEM format
    :param http_key: the private key for http_cert in PEM format
    :param vault: an optional vault client for generating certs
    :return a dictionary ready to be written to consul
    """

    if not vault:
        vault = get_vault()

    ca_cert = create_customer_ca(vault, customer_shortname)
    tcp_key, tcp_cert = \
        create_tcp_wildcard_cert(vault, customer_shortname, customer_fqdn)
    hostagent_key, hostagent_cert = \
        create_hostagent_cert(vault, customer_shortname)

    certs_to_save = [
        ('ca', ca_cert, None),
        ('decco-tcp', tcp_cert, tcp_key),
        ('web', http_cert, http_key),
        ('hostagent', hostagent_cert, hostagent_key)
    ]
    certs = {
        'current_version': 'v0',
        'v0': {}
    }
    for name, cert, key in certs_to_save:
        certs['v0'][name] = {
            'cert': cert,
            'key': key
        }
    return certs


def get_vault():
    vault_addr = os.getenv('VAULT_ADDR',
                           'https://vault-dev.platform9.horse:8200')
    LOG.info('Using vault at %s', vault_addr)
    try:
        vault_token = os.getenv('VAULT_TOKEN')
    except KeyError:
        raise Exception('Please provide a vault access token in '
                        'the VAULT_TOKEN environment variable.')
    return VaultCA(vault_addr, vault_token)


def create_customer_ca(vault, shortname):
    """
    Create a CA for the customer. Returns the self-signed CA cert. The
    private key is held in vault.
    :return: string PEM CA cert.
    """
    vault.create_ca(shortname, 'Customer CA for %s' % shortname)
    ca_info = vault.new_ca_root(shortname, shortname)
    return ca_info.json()['data']['certificate']


def create_tcp_wildcard_cert(vault, shortname, fqdn):
    """
    Create a private key, csr and signed cert for services named
    *.<shortname>.cluster.local and *.<fqdn>.
    :return: the key and cert as PEM strings.
    """
    tcp_wildcard_cn = '*.%s' % fqdn
    subj_alt_name = '*.%s.svc.cluster.local' % shortname
    tcp_key, csr_pem = generate_key_and_csr(tcp_wildcard_cn)
    signing_role = '%s-wildcard' % shortname
    vault.create_signing_role(shortname, signing_role)
    cert_info = vault.sign_csr(shortname, signing_role, csr_pem,
                               common_name=tcp_wildcard_cn,
                               alt_names=[tcp_wildcard_cn, subj_alt_name])
    return tcp_key, cert_info.json()['data']['certificate']


def create_hostagent_cert(vault, shortname):
    """
    Create a private key, csr and signed cert for hostagent
    :return: the key and cert as PEM strings.
    """
    cn = 'hostagent'
    tcp_key, csr_pem = generate_key_and_csr(cn)
    signing_role = '%s-hostagent' % shortname
    vault.create_signing_role(shortname, signing_role)
    cert_info = vault.sign_csr(shortname, signing_role, csr_pem, cn)
    return tcp_key, cert_info.json()['data']['certificate']


def generate_key_and_csr(common_name):
    private_key = rsa.generate_private_key(public_exponent=65537,
                                           key_size=2048,
                                           backend=default_backend())
    builder = x509.CertificateSigningRequestBuilder()
    builder = builder.subject_name(x509.Name([
                x509.NameAttribute(NameOID.COMMON_NAME,
                                   unicode(common_name))]))
    builder = builder.add_extension(
        x509.BasicConstraints(ca=False, path_length=None), critical=True)
    request = builder.sign(private_key, hashes.SHA256(), default_backend())
    return (
        private_key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8,
                                  NoEncryption()),
        request.public_bytes(Encoding.PEM)
    )
